{"docstore/data": {"adfe5e37-53c1-47ad-8816-b073302ab04d": {"__data__": {"id_": "adfe5e37-53c1-47ad-8816-b073302ab04d", "embedding": null, "metadata": {"Header_2": " Why build this?", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92", "node_type": "4", "metadata": {"filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "1c1bcded2311b3bf3b83b277223a74fe78e34955fa9683f403b6960bc5a3828b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dab75223-96dc-4c1d-a812-c5838f8a62bd", "node_type": "1", "metadata": {"Header_2": " What we built"}, "hash": "b8a768418c62bc101303d9670810da705995c6db1ad3315963b8d1884c46d889", "class_name": "RelatedNodeInfo"}}, "text": "Why build this?\n\nInteractive chat bots are by this point a familiar solution to customer\nservice, and agents are a frequent component of chat bot implementations. They\nprovide memory, introspection, tool use and other features necessary for a\ncompetent bot.\n\nWe have become interested in larger-scale chatbots: ones that can complete\ndozens of tasks, some of which have dependencies on each other, using hundreds\nof tools. What would that agent look like? It would have an enormous system\nprompt and a huge number of tools to choose from, which can be confusing for\nan agent.\n\nImagine a bank implementing a system that can:\n\n  * Look up the price of a specific stock \n  * Authenticate a user \n  * Check your account balance \n    * Which requires the user be authenticated \n  * Transfer money between accounts \n    * Which requires the user be authenticated \n    * And also that the user checks their account balance first \n\nEach of these top-level tasks has sub-tasks, for instance:\n\n  * The stock price lookup might need to look up the stock symbol first \n  * The user authentication would need to gather a username and a password \n  * The account balance would need to know which of the user's accounts to check \n\nComing up with a single primary prompt for all of these tasks and sub-tasks\nwould be very complex. So instead, we designed a multi-agent system with\nagents responsible for each top-level task, plus a \"concierge\" agent that can\ndirect the user to the correct agent.", "mimetype": "text/plain", "start_char_idx": 4, "end_char_idx": 1484, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dab75223-96dc-4c1d-a812-c5838f8a62bd": {"__data__": {"id_": "dab75223-96dc-4c1d-a812-c5838f8a62bd", "embedding": null, "metadata": {"Header_2": " What we built", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92", "node_type": "4", "metadata": {"filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "1c1bcded2311b3bf3b83b277223a74fe78e34955fa9683f403b6960bc5a3828b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "adfe5e37-53c1-47ad-8816-b073302ab04d", "node_type": "1", "metadata": {"Header_2": " Why build this?", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "df974514cb95aab01f2d57ef9988e5e69c74b12310bc8927b3d3e2d8ff8d5371", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d67b5020-ed23-4d42-8cb6-ffb82225dc35", "node_type": "1", "metadata": {"Header_2": " The system in action"}, "hash": "6fb7ffe7ff1e91a1146c3ac29226b84464656c903a2045ea014f4e7d9a5a9431", "class_name": "RelatedNodeInfo"}}, "text": "What we built\n\nWe built a system of agents to complete the above tasks. [ It's open-source\n](https://github.com/run-llama/multi-agent-concierge/) ! There are four basic\n\"task\" agents:\n\n  * A stock lookup agent (which takes care of sub-tasks like looking up symbols) \n  * An authentication agent (which asks for username and password) \n  * An account balance agent (which takes care of sub-tasks like selecting an account) \n  * A money transfer agent (which takes care of tasks like asking what account to transfer to, and how much) \n\nThere are also three \"meta\" agents:\n\n  1. A **concierge agent** : this agent is responsible for interacting with the user when they first arrive, letting them know what sort of tasks are available, and providing feedback when tasks are complete. \n  2. An **orchestration agent** : this agent never provides output directly to the user. Instead, it looks at what the user is currently trying to accomplish, and responds with the plain-text name of the agent that should handle the task. The code then routes to that agent. \n  3. A **continuation agent** : it's sometimes necessary to chain agents together to complete a task. For instance, to check your account balance, you need to be authenticated first. The authentication agent doesn't know if you were simply trying to authenticate yourself or if it's part of a chain, and it doesn't need to. When the authentication agent completes, the continuation agent checks chat history to see what the original task was, and if there's more to do, it formulates a new request to the orchestration agent to get you there without further user input. \n\nA **global state** keeps track of the user and their current state, shared\nbetween all the agents.\n\nThe flow of the the system looks something like this:", "mimetype": "text/plain", "start_char_idx": 1490, "end_char_idx": 3272, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d67b5020-ed23-4d42-8cb6-ffb82225dc35": {"__data__": {"id_": "d67b5020-ed23-4d42-8cb6-ffb82225dc35", "embedding": null, "metadata": {"Header_2": " The system in action", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92", "node_type": "4", "metadata": {"filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "1c1bcded2311b3bf3b83b277223a74fe78e34955fa9683f403b6960bc5a3828b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dab75223-96dc-4c1d-a812-c5838f8a62bd", "node_type": "1", "metadata": {"Header_2": " What we built", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "3a25e4cb8f1dd6c624ee2c257c6c9264ad5285011f6dfcdc5c5360d8d7a10126", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27220421-76a6-4912-9024-76b308d041c3", "node_type": "1", "metadata": {"Header_2": " The code"}, "hash": "5d0ca323718cbde88881a0887a2076cc06a0d40cca300a16143d733230200a06", "class_name": "RelatedNodeInfo"}}, "text": "The system in action\n\nTo get a sense of how this works in practice, here's sample output including\nhelpful debug statements. Output that would be ordinarily shown to the user\nhas two ` >> ` , while user input has one ` > ` .\n\nAt the beginning of the conversation nothing's happened yet, so you get routed\nto the concierge:\n\n    \n    \n    No current speaker, asking orchestration agent to decide\n    \n    Concierge agent selected\n    \n    >> Hi there! How can I assist you today? Here are some things I can help you with:\n    \n    >> Looking up a stock price\n    \n    >> Authenticating you\n    \n    >> Checking an account balance (requires authentication first)\n    \n    >> Transferring money between accounts (requires authentication and checking an account balance first)\n    \n    >> What would you like to do?\n    \n    > Transfer money\n\nThe \"transfer money\" task requires authentication. The orchestration agent\nchecks if you're authenticated while deciding how to route you (it does this\ntwice for some reason, it's a demo!):\n\n    \n    \n    No current speaker, asking orchestration agent to decide\n    \n    Orchestrator is checking if authenticated\n    \n    Orchestrator is checking if authenticated\n    \n    Auth agent selected\n\nIt correctly determines you're not authenticated, so it routes you to the\nauthentication agent:\n\n    \n    \n    >> To transfer money, I need to authenticate you first. Could you please provide your username and password?\n    \n    > seldo\n\nThis is a fun part: you've provided input, but it's not sufficient to complete\nthe task (you didn't give a password). So when the flow goes back to the\norchestration agent, the global state indicates that the \"authenticate\" agent\nis already running and hasn't completed yet, so it routes back to the\nauthentication agent, and does that again for the password:\n\n    \n    \n    There's already a speaker: authenticate\n    \n    Auth agent selected\n    \n    Recording username\n    \n    >> Thank you! Now, could you please provide your password?\n    \n    > monkey\n    \n    There's already a speaker: authenticate\n    \n    Auth agent selected\n    \n    Logging in seldo\n    \n    Checking if authenticated\n    \n    Authentication is complete\n\nNow the auth agent has called a done() function that indicates to the global\nstate that it has completed its task. So the flow now goes to the continuation\nagent, which looks at the chat history and sees that the user was trying to\ntransfer money. So it generates a prompt, as if spoken by the user, and sends\nthat to the orchestration agent:\n\n    \n    \n    >> You have been successfully authenticated. Another agent will assist you with transferring money.\n    \n    Asking the continuation agent to decide what to do next\n    \n    Continuation agent said \"I would like to transfer money.\"\n    \n    No current speaker, asking orchestration agent to decide\n    \n    Orchestrator checking if account has a balance\n    \n    Orchestrator checking if account has a balance\n    \n    Account balance agent selected\n\nNow you're authenticated, but you haven't checked your balance yet, which the\norchestration agent knows is necessary for transferring money. So it routes\nyou to the account balance agent (after checking twice for some reason):\n\n    \n    \n    >> Before you can transfer money, you need to check your account balance. Let's start by looking up your account balance. Could you please provide the name of the account you're interested in?\n    \n    > Checking\n    \n    There's already a speaker: account_balance\n    \n    Account balance agent selected\n    \n    Looking up account ID for Checking\n    \n    Looking up account balance for 1234567890\n    \n    Account balance lookup is complete\n    \n    >> Your Checking account has a balance of $1000. Another agent will assist you with transferring money.\n    \n    Asking the continuation agent to decide what to do next\n    \n    Continuation agent said \"I would like to transfer money.\"\n    \n    No current speaker, asking orchestration agent to decide\n    \n    Transfer money agent selected\n\nThe account balance agent asks you which account, uses a tool to get the ID\nfor that account, and then marks itself as done. The continuation agent kicks\nin again and sees that you still haven't completed your original task of\ntransferring money, so it prompts the orchestrator agent again. Unfortunately\nthe orchestrator gets a little confused, and loops twice before finally\nrouting you to the transfer money agent:\n\n    \n    \n    Money transfer is complete\n    \n    >> Another agent will assist you with transferring money.\n    \n    Asking the continuation agent to decide what to do next\n    \n    Continuation agent said \"I would like to transfer money.\"\n    \n    No current speaker, asking orchestration agent to decide\n    \n    Transfer money agent selected\n    \n    Money transfer is complete\n    \n    >> Another agent will assist you with transferring money.\n    \n    Asking the continuation agent to decide what to do next\n    \n    Continuation agent said \"I would like to transfer money.\"\n    \n    No current speaker, asking orchestration agent to decide\n    \n    Orchestrator checking if account has a balance\n    \n    Transfer money agent selected\n    \n    >> You have already checked your account balance. Please provide the following details to proceed with the money transfer:\n    \n    >> 1. The account ID to which you want to transfer the money.\n    \n    >> 2. The amount you want to transfer.\n    \n    > To account ID 1234324\n    \n    There's already a speaker: transfer_money\n    \n    Transfer money agent selected\n    \n    >> How much would you like to transfer to account ID 1234324?\n    \n    > 500\n    \n    There's already a speaker: transfer_money\n    \n    Transfer money agent selected\n    \n    Checking if balance is sufficient\n    \n    Transferring 500 from 1234567890 account 1234324\n    \n    Money transfer is complete\n    \n    >> The transfer of $500 to account ID 1234324 has been successfully completed. If you need any further assistance, feel free to ask!\n    \n    Asking the continuation agent to decide what to do next\n    \n    Continuation agent said no_further_tasks\n\nWe've reached the end of the task! The continuation agent sees that there are\nno further tasks, and routes you back to the concierge.", "mimetype": "text/plain", "start_char_idx": 3278, "end_char_idx": 9567, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27220421-76a6-4912-9024-76b308d041c3": {"__data__": {"id_": "27220421-76a6-4912-9024-76b308d041c3", "embedding": null, "metadata": {"Header_2": " The code", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92", "node_type": "4", "metadata": {"filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "1c1bcded2311b3bf3b83b277223a74fe78e34955fa9683f403b6960bc5a3828b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d67b5020-ed23-4d42-8cb6-ffb82225dc35", "node_type": "1", "metadata": {"Header_2": " The system in action", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "230a9f8cdf1915cd405f23c5ed895416819b3b39c3a0e8d281e0752c881441a1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "881d1119-0e24-4d32-a679-b2b42b131604", "node_type": "1", "metadata": {"Header_2": " What's next"}, "hash": "c92c0cbcb29b47a76569c7d6376c6832e9d1351e0cb143d425c52665e3e7f210", "class_name": "RelatedNodeInfo"}}, "text": "The code\n\nNow let's look at some highlights of the code that gets all of this done. The\ncore of the system is a central loop that runs forever. At the core of that is\na very simple block that simply asks the orchestration agent who should speak\nnext, and sets the ` next_speaker ` value which is contained in the state\nobject that is passed between all the agents. Note that if there's already a\nsub-agent speaking, that agent gets to keep speaking.\n\n    \n    \n    current_history = root_memory.get()\n    \n    # who should speak next?\n    if (state[\"current_speaker\"]):\n      print(f\"There's already a speaker: {state['current_speaker']}\")\n      next_speaker = state[\"current_speaker\"]\n    else:\n      print(\"No current speaker, asking orchestration agent to decide\")\n      orchestration_response = orchestration_agent_factory(state).chat(\n        user_msg_str, \n        chat_history=current_history\n      )\n      next_speaker = str(orchestration_response).strip()\n\nThe orchestration agent has a very strict prompt; its output only goes to\nother machines. It includes a natural-language summary of the dependencies\nbetween agents:\n\n    \n    \n        system_prompt = (f\"\"\"\n            You are on orchestration agent.\n            Your job is to decide which agent to run based on the current state of the user and what they've asked to do. Agents are identified by short strings.\n            What you do is return the name of the agent to run next. You do not do anything else.\n            \n            The current state of the user is:\n            {pprint.pformat(state, indent=4)}\n    \n            If a current_speaker is already selected in the state, simply output that value.\n    \n            If there is no current_speaker value, look at the chat history and the current state and you MUST return one of these strings identifying an agent to run:\n            * \"{Speaker.STOCK_LOOKUP.value}\" - if they user wants to look up a stock price (does not require authentication)\n            * \"{Speaker.AUTHENTICATE.value}\" - if the user needs to authenticate\n            * \"{Speaker.ACCOUNT_BALANCE.value}\" - if the user wants to look up an account balance\n                * If they want to look up an account balance, but they haven't authenticated yet, return \"{Speaker.AUTHENTICATE.value}\" instead\n            * \"{Speaker.TRANSFER_MONEY.value}\" - if the user wants to transfer money between accounts (requires authentication and checking an account balance first)\n                * If they want to transfer money, but is_authenticated returns false, return \"{Speaker.AUTHENTICATE.value}\" instead\n                * If they want to transfer money, but has_balance returns false, return \"{Speaker.ACCOUNT_BALANCE.value}\" instead\n            * \"{Speaker.CONCIERGE.value}\" - if the user wants to do something else, or hasn't said what they want to do, or you can't figure out what they want to do. Choose this by default.\n    \n            Output one of these strings and ONLY these strings, without quotes.\n            NEVER respond with anything other than one of the above five strings. DO NOT be helpful or conversational.\n        \"\"\")\n\nA simple if-else block takes the output of the orchestration agent and uses it\nto instantiate the sub-agent to run next. This is when the state object gets\npassed to each sub-agent:\n\n    \n    \n            if next_speaker == Speaker.STOCK_LOOKUP:\n                print(\"Stock lookup agent selected\")\n                current_speaker = stock_lookup_agent_factory(state)\n                state[\"current_speaker\"] = next_speaker\n            elif next_speaker == Speaker.AUTHENTICATE:\n                print(\"Auth agent selected\")\n                current_speaker = auth_agent_factory(state)\n                state[\"current_speaker\"] = next_speaker\n            elif next_speaker == Speaker.ACCOUNT_BALANCE:\n                print(\"Account balance agent selected\")\n                current_speaker = account_balance_agent_factory(state)\n                state[\"current_speaker\"] = next_speaker\n            elif next_speaker == Speaker.TRANSFER_MONEY:\n                print(\"Transfer money agent selected\")\n                current_speaker = transfer_money_agent_factory(state)\n                state[\"current_speaker\"] = next_speaker\n            elif next_speaker == Speaker.CONCIERGE:\n                print(\"Concierge agent selected\")\n                current_speaker = concierge_agent_factory(state)\n            else:\n                print(\"Orchestration agent failed to return a valid speaker; ask it to try again\")\n                is_retry = True\n                continue\n\nAnd then the full chat history is passed as part of a regular chat message to\nthe newly-instantiated agent:\n\n    \n    \n    response = current_speaker.chat(user_msg_str, chat_history=current_history)\n\nThe agent reads its prompt and the user input and decides what to say. As we\nsaw in our very first block of code, if the speaker is already selected, then\nthe loop will keep talking to the current sub-agent. This continues until the\nsub-agent has completed its task, at which point its prompt instructs it to\ncall the ` done() ` function:\n\n    \n    \n        def done() -> None:\n            \"\"\"When you complete your task, call this tool.\"\"\"\n            print(\"Money transfer is complete\")\n            state[\"current_speaker\"] = None\n            state[\"just_finished\"] = True\n\nThis modifies the state, setting the current speaker to none. This triggers\nthe outer loop to run the continuation agent, to see if there's anything else\nto do:\n\n    \n    \n            elif state[\"just_finished\"] == True:\n                print(\"Asking the continuation agent to decide what to do next\")\n                user_msg_str = str(continuation_agent_factory(state).chat(\"\"\"\n                    Look at the chat history to date and figure out what the user was originally trying to do.\n                    They might have had to do some sub-tasks to complete that task, but what we want is the original thing they started out trying to do.                                                                      \n                    Formulate a sentence as if written by the user that asks to continue that task.\n                    If it seems like the user really completed their task, output \"no_further_task\" only.\n                \"\"\", chat_history=current_history))\n                print(f\"Continuation agent said {user_msg_str}\")\n                if user_msg_str == \"no_further_task\":\n                    user_msg_str = input(\">> \").strip()\n                state[\"just_finished\"] = False\n\nThe continuation agent's prompt instructs it to reply as if it were the user\nasking to perform a task, or to output ` no_further_task ` if there's no more\nto do. If there's a new task, the output of the continuation agent becomes the\ninput to the orchestrator, which selects a new speaker. If there's no further\ntask, the loop pauses for more user input.\n\nAnd that's the full system! The sub-agents can be arbitrarily complicated,\nmulti-turn systems in themselves, and the outer loop doesn't need to know how\nthey work, just how they depend on each other.", "mimetype": "text/plain", "start_char_idx": 9573, "end_char_idx": 16696, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "881d1119-0e24-4d32-a679-b2b42b131604": {"__data__": {"id_": "881d1119-0e24-4d32-a679-b2b42b131604", "embedding": null, "metadata": {"Header_2": " What's next", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92", "node_type": "4", "metadata": {"filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "1c1bcded2311b3bf3b83b277223a74fe78e34955fa9683f403b6960bc5a3828b", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27220421-76a6-4912-9024-76b308d041c3", "node_type": "1", "metadata": {"Header_2": " The code", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}, "hash": "db614bd017997eb9a9eb851b425bdbed347b22cf7c6300dd33fb8198583a5d4e", "class_name": "RelatedNodeInfo"}}, "text": "What's next\n\nWe think there's some novel stuff in here: coordinating multiple agents\n\"speaking\" simultaneously, creating implicit \"chains\" of agents through\nnatural language instructions, using a \"continuation\" agent to manage those\nchains, and using a global state this way. We're excited to see what you do\nwith the patterns we've laid out here. Don't forget to [ check out the open-\nsource repo ](https://github.com/run-llama/multi-agent-concierge/) !", "mimetype": "text/plain", "start_char_idx": 16702, "end_char_idx": 17156, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/metadata": {"adfe5e37-53c1-47ad-8816-b073302ab04d": {"doc_hash": "df974514cb95aab01f2d57ef9988e5e69c74b12310bc8927b3d3e2d8ff8d5371", "ref_doc_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92"}, "dab75223-96dc-4c1d-a812-c5838f8a62bd": {"doc_hash": "3a25e4cb8f1dd6c624ee2c257c6c9264ad5285011f6dfcdc5c5360d8d7a10126", "ref_doc_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92"}, "d67b5020-ed23-4d42-8cb6-ffb82225dc35": {"doc_hash": "230a9f8cdf1915cd405f23c5ed895416819b3b39c3a0e8d281e0752c881441a1", "ref_doc_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92"}, "27220421-76a6-4912-9024-76b308d041c3": {"doc_hash": "db614bd017997eb9a9eb851b425bdbed347b22cf7c6300dd33fb8198583a5d4e", "ref_doc_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92"}, "881d1119-0e24-4d32-a679-b2b42b131604": {"doc_hash": "f3336191d9f2ab0a647f0ae78b3276a5ceb9907b648846e4ceb4b17839c887b5", "ref_doc_id": "fe1de819-46dd-4b6c-b812-dce886d7fc92"}}, "docstore/ref_doc_info": {"fe1de819-46dd-4b6c-b812-dce886d7fc92": {"node_ids": ["adfe5e37-53c1-47ad-8816-b073302ab04d", "dab75223-96dc-4c1d-a812-c5838f8a62bd", "d67b5020-ed23-4d42-8cb6-ffb82225dc35", "27220421-76a6-4912-9024-76b308d041c3", "881d1119-0e24-4d32-a679-b2b42b131604"], "metadata": {"Header_2": " Why build this?", "filename": "building-a-multi-agent-concierge-system.md", "extension": ".md", "title": "Building a multi-agent concierge system", "date": "Jul 17, 2024", "url": "https://www.llamaindex.ai/blog/building-a-multi-agent-concierge-system"}}}}