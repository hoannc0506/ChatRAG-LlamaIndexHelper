{"docstore/data": {"c841782b-c9ba-4fda-b0b8-8bd2cb03396b": {"__data__": {"id_": "c841782b-c9ba-4fda-b0b8-8bd2cb03396b", "embedding": null, "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8d63857f-44bf-45f5-a327-5833745751d6", "node_type": "1", "metadata": {"Header_1": " Faster Vector Similarity Search in PostgreSQL"}, "hash": "5f210dfef3374d8fcfcaf31e5427f0b0edc42e0b71e0267ab4d99785f8df654f", "class_name": "RelatedNodeInfo"}}, "text": "Authors: Avthar Sewrathan, Matvey Arye, Jerry Liu, Yi Ding\n\nIntroducing the [ Timescale Vector ](https://www.timescale.com/ai) integration\nfor LlamaIndex. Timescale Vector enables LlamaIndex developers to build better\nAI applications with PostgreSQL as their vector database: with faster vector\nsimilarity search, efficient time-based search filtering, and the operational\nsimplicity of a single, easy-to-use cloud PostgreSQL database for not only\nvector embeddings but an AI application\u2019s relational and time-series data too.\n\nPostgreSQL is the world\u2019s most loved database, according to the [ Stack\nOverflow 2023 Developer Survey\n](https://survey.stackoverflow.co/2023/#section-most-popular-technologies-\ndatabases) . And for a good reason: it\u2019s been battle-hardened by production\nuse for over three decades, it\u2019s robust and reliable, and it has a rich\necosystem of tools, drivers, and connectors.\n\nAnd while pgvector, the open-source extension for vector data on PostgreSQL,\nis a wonderful extension (and all its features are offered as part of\nTimescale Vector), it is just one piece of the puzzle in providing a\nproduction-grade experience for AI application developers on PostgreSQL. After\nspeaking with numerous developers at nimble startups and established industry\ngiants, we saw the need to enhance pgvector to cater to the performance and\noperational needs of developers building AI applications.\n\nHere\u2019s the TL;DR on how Timescale Vector helps you build better AI\napplications with LlamaIndex:\n\n  * **Faster similarity search on millions of vectors:** Thanks to the introduction of a new search index inspired by the DiskANN algorithm, [ Timescale Vector achieves 3X faster search speed at ~99% recall than a specialized database ](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-database/?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral) and outperforms all existing PostgreSQL search indexes by between 39.39% and 1,590.33% on a dataset of one million OpenAI embeddings. Plus, enabling product quantization yields a [ 10x index space savings compared to pgvector ](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-database/?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral) . Timescale Vector also offers pgvector\u2019s Hierarchical Navigable Small Worlds (HNSW) and Inverted File Flat (IVFFlat) indexing algorithms. \n  * **Efficient similarity search with time-based filtering:** Timescale Vector optimizes time-based vector search queries, leveraging the automatic time-based partitioning and indexing of [ Timescale\u2019s hypertables ](https://docs.timescale.com/use-timescale/latest/hypertables/) to efficiently find recent embeddings, constrain vector search by a time range or document age, and store and retrieve large language model (LLM) response and chat history with ease. Time-based semantic search also enables you to use Retrieval Augmented Generation (RAG) with time-based context retrieval to give users more useful LLM responses. \n  * **Simplified AI infra stack:** By combining vector embeddings, relational data, and time-series data in one PostgreSQL database, Timescale Vector eliminates the operational complexity that comes with managing multiple database systems at scale. \n  * **Simplified metadata handling and multi-attribute filtering:** Developers can leverage all PostgreSQL data types to store and filter metadata and JOIN vector search results with relational data for more contextually relevant responses. In future releases, Timescale Vector will further optimize rich multi-attribute filtering, enabling even faster similarity searches when filtering on metadata. \n\nOn top of these innovations for vector workloads, Timescale Vector provides a\nrobust, production-ready cloud PostgreSQL platform with flexible pricing,\nenterprise-grade security, and free expert support.\n\nIn the rest of this post, we\u2019ll dive deeper (with code!) into the unique\ncapabilities Timescale Vector enables for developers wanting to use PostgreSQL\nas their vector database with LlamaIndex:\n\n  * Faster similarity search with DiskANN, HNSW and IVFFlat index types. \n  * Efficient similarity search when filtering vectors by time. \n  * Retrieval Augmented Generation (RAG) with time-based context retrieval. \n\n(If you want to jump straight to the code, explore [ this tutorial\n](https://gpt-\nindex.readthedocs.io/en/stable/examples/vector_stores/Timescalevector.html) ).\n\n**** [ **LlamaIndex Users Get 3 Months of Timescale Vector for Free**\n](https://console.cloud.timescale.com/signup?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral)\n\nWe\u2019re giving LlamaIndex users an extended 90-day trial of Timescale Vector.\nThis makes it easy to test and develop your applications on Timescale Vector,\nas you won\u2019t be charged for any cloud PostgreSQL databases you spin up during\nyour trial period. [ Try Timescale Vector for free today\n](https://console.cloud.timescale.com/signup?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral)\n.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5056, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8d63857f-44bf-45f5-a327-5833745751d6": {"__data__": {"id_": "8d63857f-44bf-45f5-a327-5833745751d6", "embedding": null, "metadata": {"Header_1": " Faster Vector Similarity Search in PostgreSQL", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c841782b-c9ba-4fda-b0b8-8bd2cb03396b", "node_type": "1", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "32a9aa0df5d87b2e6abcbe3f00f732db49b68042eeaaf323878714476a0807af", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d44c680f-4c50-4825-9022-36ee14d6997d", "node_type": "1", "metadata": {"Header_1": " Add Efficient Time-Based Search Functionality to Your LlamaIndex AI"}, "hash": "55bf854721a336333a74f98081e204a1afcba0d1208393d8bd0981a0dbb59bd8", "class_name": "RelatedNodeInfo"}}, "text": "Faster Vector Similarity Search in PostgreSQL\n\nTimescale Vector speeds up Approximate Nearest Neighbor (ANN) search on large-\nscale vector datasets, enhancing pgvector with a state-of-the-art ANN index\ninspired by the [ DiskANN ](https://www.microsoft.com/en-\nus/research/publication/diskann-fast-accurate-billion-point-nearest-neighbor-\nsearch-on-a-single-node/) algorithm. Timescale Vector also offers pgvector\u2019s\nHNSW and IVFFlat indexing algorithms, giving developers the flexibility to\nchoose the right index for their use case.\n\nOur performance benchmarks using the [ ANN benchmarks\n](https://github.com/erikbern/ann-benchmarks/) suite show that Timescale\nVector achieves between 39.43% and 1,590.33% faster search speed at ~99%\nrecall than all existing PostgreSQL search indexes, and 3X faster search speed\nat ~99% recall than specialized vector databases on a dataset of one million\nOpenAI embeddings. You can [ read more about the performance benchmark\nmethodology, the databases compared and results here\n](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-\ndatabase/?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral)\n.\n\n_Timescale Vector\u2019s new DiskANN-inspired index outperforms all existing\nPostgreSQL index types when performing approximate nearest neighbor searches\nat 99 % recall on 1 million OpenAI embeddings._\n\nUsing Timescale Vector\u2019s DiskANN, HNSW, or IVFFLAT indexes in LlamaIndex is\nincredibly straightforward.\n\nSimply create a Timescale Vector vector store and add the [ data nodes\n](https://gpt-\nindex.readthedocs.io/en/latest/core_modules/data_modules/documents_and_nodes/usage_nodes.html)\nyou want to query as shown below:\n\n    \n    \n    from llama_index.vector_stores import TimescaleVectorStore\n    \n    # Create a timescale vector store with specified params\n    ts_vector_store = TimescaleVectorStore.from_params(\n       service_url=TIMESCALE_SERVICE_URL,\n       table_name=\"your_table_name\",\n       time_partition_interval= timedelta(days=7),\n    )\n    ts_vector_store.add(nodes)\n\nThen run:\n\n    \n    \n    # Create a timescale vector index (DiskANN)\n    ts_vector_store.create_index()\n\nThis will create a timescale-vector index with the default parameters.\n\nWe should point out that the term \u201cindex\u201d is a bit overloaded. For many\nVectorStores, an index is the thing that stores your data (in relational\ndatabases this is often called a table), but in the PostgreSQL world an index\nis something that speeds up search, and we are using the latter meaning here.\n\nWe can also specify the exact parameters for index creation in the `\ncreate_index ` command as follows:\n\n    \n    \n    # create new timescale vector index (DiskANN) with specified parameters\n    ts_vector_store.create_index(\"tsv\", max_alpha=1.0, num_neighbors=50)\n\nAdvantages to this Timescale Vector\u2019s new DiskANN-inspired vector search index\ninclude the following:\n\n  * Faster vector search at 99% accuracy in PostgreSQL. \n  * Optimized for running on disks, not only in memory use. \n  * Quantization optimization compatible with PostgreSQL, reducing the vector size and consequently shrinking the index size ( [ by 10x in some cases ](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-database/?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral) !) and expediting searches. \n  * Efficient hybrid search or filtering additional dimensions. \n\nFor more on how Timescale Vector\u2019s new index works, [ see this blog post\n](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-\ndatabase/?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral)\n.\n\nPgvector is packaged as part of Timescale Vector, so you can also access\npgvector\u2019s HNSW and IVFFLAT indexing algorithms in your LlamaIndex\napplications. The ability to conveniently create ANN search indexes from your\nLlamaIndex application code makes it easy to create different indexes and\ncompare their performance:\n\n    \n    \n    # Create an HNSW index\n    # Note: You don't need to specify m and ef_construction parameters as we set smart defaults.\n    ts_vector_store.create_index(\"hnsw\", m=16, ef_construction=64)\n    \n    # Create an IVFFLAT index\n    # Note: You don't need to specify num_lists and num_records parameters as we set smart defaults.\n    ts_vector_store.create_index(\"ivfflat\", num_lists=20, num_records=1000)", "mimetype": "text/plain", "start_char_idx": 5061, "end_char_idx": 9432, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d44c680f-4c50-4825-9022-36ee14d6997d": {"__data__": {"id_": "d44c680f-4c50-4825-9022-36ee14d6997d", "embedding": null, "metadata": {"Header_1": " Add Efficient Time-Based Search Functionality to Your LlamaIndex AI", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8d63857f-44bf-45f5-a327-5833745751d6", "node_type": "1", "metadata": {"Header_1": " Faster Vector Similarity Search in PostgreSQL", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "7ee6f257cf171c89e664bdf78a31f5627dd3ee3421b430e39d6b98c51017b7a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d12bd5ff-cac6-47d9-8016-9aa45a77c68b", "node_type": "1", "metadata": {"Header_1": " Create nodes from each commit in the gitlog"}, "hash": "56a86199a772743c5cecf4ab150b93921a70f75f426a435cd4a182ee9221a676", "class_name": "RelatedNodeInfo"}}, "text": "Add Efficient Time-Based Search Functionality to Your LlamaIndex AI\nApplication\n\nTimescale Vector optimizes time-based vector search, leveraging the automatic\ntime-based partitioning and indexing of [ Timescale\u2019s hypertables\n](https://docs.timescale.com/use-timescale/latest/hypertables/) to efficiently\nsearch vectors by time and similarity.\n\nTime is often an important metadata component for vector embeddings. Sources\nof embeddings, like documents, images, and web pages, often have a timestamp\nassociated with them, for example, their creation date, publishing date, or\nthe date they were last updated, to name but a few.\n\nWe can take advantage of this time metadata in our collections of vector\nembeddings to enrich the quality and applicability of search results by\nretrieving vectors that are not just semantically similar but also pertinent\nto a specific time frame.\n\nHere are some examples where time-based retrieval of vectors can improve your\nLlamaIndex applications:\n\n  * **Finding recent embeddings:** Finding the most recent embeddings that are semantically similar to a query vector. For example, finding the most recent news, documents, or social media posts related to elections. \n  * **Search within a time-range:** Constraining similarity search to only vectors within a relevant time range. For example, asking time-based questions about a knowledge base (\u201cWhat new features were added between January and March 2023?\u201d). \n  * **Chat history:** Storing and retrieving LLM response history. For example, chatbot chat history. \n\nLet\u2019s take a look at an example of performing time-based searches on a [ git\nlog dataset\n](https://chat.openai.com/share/0612295b-a408-4e02-9ac2-3dc231fa89d1) . In a\ngit log, each entry has a timestamp, an author, and some information about the\ncommit.\n\nTo illustrate how to use TimescaleVector\u2019s time-based vector search\nfunctionality, we\u2019ll ask questions about the git log history for TimescaleDB.\nEach git commit entry has a timestamp associated with it, as well as a message\nand other metadata (e.g., author).\n\nWe\u2019ll illustrate how to create nodes with a time-based UUID and how to run\nsimilarity searches with time range filters using the Timescale Vector vector\nstore..", "mimetype": "text/plain", "start_char_idx": 9437, "end_char_idx": 11658, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d12bd5ff-cac6-47d9-8016-9aa45a77c68b": {"__data__": {"id_": "d12bd5ff-cac6-47d9-8016-9aa45a77c68b", "embedding": null, "metadata": {"Header_1": " Create nodes from each commit in the gitlog", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d44c680f-4c50-4825-9022-36ee14d6997d", "node_type": "1", "metadata": {"Header_1": " Add Efficient Time-Based Search Functionality to Your LlamaIndex AI", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "528c837f4930444b78a773e53427158dfbf7dea1b401133e9cb39ac97b7e3d25", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9802ab2e-05ae-463e-8d10-8239ad0af361", "node_type": "1", "metadata": {"Header_1": " Create UUIDs for each node based on the date of each git commit"}, "hash": "e303afecf3361cc2ed584b57bcec81e15a4cae5c869662bd7da660dedd0c3e4a", "class_name": "RelatedNodeInfo"}}, "text": "Create nodes from each commit in the gitlog\n\nFirst, we load the git log entries from the [ demo CSV file\n](https://s3.amazonaws.com/assets.timescale.com/ai/commit_history.csv) using\nPandas:\n\n    \n    \n    import pandas as pd\n    from pathlib import Path\n    \n    \n    # Read the CSV file into a DataFrame\n    file_path = Path(\"../data/csv/commit_history.csv\")\n    df = pd.read_csv(file_path)\n\nNext, we\u2019ll create nodes of type `TextNode` for each commit in our git log\ndataset, extracting the relevant information and assigning it to the node\u2019s\ntext and metadata, respectively.\n\n    \n    \n    from llama_index.schema import TextNode, NodeRelationship, RelatedNodeInfo\n    # Create a Node object from a single row of data\n    def create_node(row):\n       record = row.to_dict()\n       record_name = split_name(record[\"author\"])\n       record_content = str(record[\"date\"]) + \" \" + record_name + \" \" + str(record[\"change summary\"]) + \" \" + str(record[\"change details\"])\n       node = TextNode(\n           id_=create_uuid(record[\"date\"]),\n           text= record_content,\n           metadata={\n               'commit': record[\"commit\"],\n               'author': record_name,\n               'date': create_date(record[\"date\"]),\n           }\n       )\n       return node\n    \n    nodes = [create_node(row) for _, row in df.iterrows()]\n\n**Note:** The code above references two helper functions to get things in the\nright format (`split_name()` and `create_date()`), which we\u2019ve omitted for\nbrevity. The full code is included in the tutorial linked in the Resources\nsection at the end of this post.", "mimetype": "text/plain", "start_char_idx": 11663, "end_char_idx": 13251, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9802ab2e-05ae-463e-8d10-8239ad0af361": {"__data__": {"id_": "9802ab2e-05ae-463e-8d10-8239ad0af361", "embedding": null, "metadata": {"Header_1": " Create UUIDs for each node based on the date of each git commit", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d12bd5ff-cac6-47d9-8016-9aa45a77c68b", "node_type": "1", "metadata": {"Header_1": " Create nodes from each commit in the gitlog", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "751691c06a58702887c72151b40b79abd2fd5f32c865caa277fd3a67603e6a38", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9e4aaf3b-a14d-4b8f-b007-189ecba2c058", "node_type": "1", "metadata": {"Header_1": " Create vector embeddings for the text of each node"}, "hash": "dd03214682b53130ac0aaa042643a6c2eb61363a765717cc3d1ff79ea097028e", "class_name": "RelatedNodeInfo"}}, "text": "Create UUIDs for each node based on the date of each git commit\n\nWe will take a closer look at a helper function we use to create each node\u2019s `\nid_ ` . For time-based search in LlamaIndex, Timescale Vector uses the\n\u2018datetime\u2019 portion of a UUID v1 to place vectors in the correct time\npartition. [ Timescale Vector\u2019s Python client library\n](https://github.com/timescale/python-vector) provides a simple-to-use\nfunction named `uuid_from_time` to create a UUID v1 from a Python DateTime\nobject, which we\u2019ll then use as our `ids` for the TextNodes.\n\n    \n    \n    from timescale_vector import client\n    # Function to take in a date string in the past and return a uuid v1\n    def create_uuid(date_string: str):\n       if date_string is None:\n           return None\n       time_format = '%a %b %d %H:%M:%S %Y %z'\n       datetime_obj = datetime.strptime(date_string, time_format)\n       uuid = client.uuid_from_time(datetime_obj)\n       return str(uuid)\n\nSince we are dealing with timestamps in the past, we take advantage of the\n`uuid_from_time` function to help generate the correct UUIDs for each node. If\nyou want the current date and time associated with your Nodes (or Documents)\nfor time-based search, you can skip this step. A UUID associated with the\ncurrent date and time will be automatically generated as the nodes are added\nto the table in Timescale Vector by default.\n\nLet\u2019s take a look at the contents of a node:\n\n    \n    \n    print(nodes[0].get_content(metadata_mode=\"all\"))\n    \n    \n    commit: 44e41c12ab25e36c202f58e068ced262eadc8d16\n    author: Lakshmi Narayanan Sreethar\n    date: 2023-09-5 21:03:21+0850\n    \n    Tue Sep 5 21:03:21 2023 +0530 Lakshmi Narayanan Sreethar Fix segfault in set_integer_now_func When an invalid function oid is passed to set_integer_now_func, it finds out that the function oid is invalid but before throwing the error, it calls ReleaseSysCache on an invalid tuple causing a segfault. Fixed that by removing the invalid call to ReleaseSysCache.  Fixes #6037", "mimetype": "text/plain", "start_char_idx": 13256, "end_char_idx": 15260, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9e4aaf3b-a14d-4b8f-b007-189ecba2c058": {"__data__": {"id_": "9e4aaf3b-a14d-4b8f-b007-189ecba2c058", "embedding": null, "metadata": {"Header_1": " Create vector embeddings for the text of each node", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9802ab2e-05ae-463e-8d10-8239ad0af361", "node_type": "1", "metadata": {"Header_1": " Create UUIDs for each node based on the date of each git commit", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "9abb3926b0b99088756df32ab5c663aa67e45b57449b0b2b05c3cba9a96e0e4f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "01a5ffa6-008d-4479-a625-53a00cef728b", "node_type": "1", "metadata": {"Header_1": " Load nodes into Timescale Vector vector store"}, "hash": "2b0c5a6ed3d6b4e825900dfcc8d19008432cc3fb930c7f515d8b9bbd773881a7", "class_name": "RelatedNodeInfo"}}, "text": "Create vector embeddings for the text of each node\n\nNext, we\u2019ll create vector embeddings of the content of each node so that we\ncan perform similarity searches on the text associated with each node. We\u2019ll\nuse the `OpenAIEmbedding` model to create the embeddings.\n\n    \n    \n    # Create embeddings for nodes\n    from llama_index.embeddings import OpenAIEmbedding\n    embedding_model = OpenAIEmbedding()\n    \n    for node in nodes:\n       node_embedding = embedding_model.get_text_embedding(\n           node.get_content(metadata_mode=\"all\")\n       )\n       node.embedding = node_embedding", "mimetype": "text/plain", "start_char_idx": 15265, "end_char_idx": 15852, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "01a5ffa6-008d-4479-a625-53a00cef728b": {"__data__": {"id_": "01a5ffa6-008d-4479-a625-53a00cef728b", "embedding": null, "metadata": {"Header_1": " Load nodes into Timescale Vector vector store", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9e4aaf3b-a14d-4b8f-b007-189ecba2c058", "node_type": "1", "metadata": {"Header_1": " Create vector embeddings for the text of each node", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "ce4a038d40d37d51340033bbebf01cf687acbc4eea7c6ff5a55f1718bc50482a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4dcbce51-7d99-4fa5-a0b2-a2ca29d74404", "node_type": "1", "metadata": {"Header_1": " Similarity search with time filters"}, "hash": "a7085b3ed4fdcc1a38c78cf88ba57a7fa71b3f706c1c1dd0cc2f32b8740596c8", "class_name": "RelatedNodeInfo"}}, "text": "Load nodes into Timescale Vector vector store\n\nNext, we\u2019ll create a `TimescaleVectorStore` instance and add the nodes we\ncreated to it.\n\n    \n    \n    # Create a timescale vector store and add the newly created nodes to it\n    ts_vector_store = TimescaleVectorStore.from_params(\n       service_url=TIMESCALE_SERVICE_URL,\n       table_name=\"li_commit_history\",\n       time_partition_interval= timedelta(days=7),\n    )\n    ts_vector_store.add(nodes)\n\nTo take advantage of Timescale Vector\u2019s efficient time-based search, we need\nto specify the `time_partition_interval` argument when instantiating a\nTimescale Vector vector store. This argument represents the length of each\ninterval for partitioning the data by time. Each partition will consist of\ndata that falls within the specified length of time.\n\nIn the example above, we use seven days for simplicity, but you can pick\nwhatever value makes sense for the queries used by your application \u2014 for\nexample, if you query recent vectors frequently, you might want to use a\nsmaller time delta like one day, or if you query vectors over a decade-long\ntime period, then you might want to use a larger time delta like six months or\none year. As a rule of thumb, common queries should touch only a couple of\npartitions and at the same time your full dataset should fit within a 1000\npartitions, but don\u2019t stress too much \u2014 the system is not very sensitive to\nthis value.", "mimetype": "text/plain", "start_char_idx": 15857, "end_char_idx": 17270, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4dcbce51-7d99-4fa5-a0b2-a2ca29d74404": {"__data__": {"id_": "4dcbce51-7d99-4fa5-a0b2-a2ca29d74404", "embedding": null, "metadata": {"Header_1": " Similarity search with time filters", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "01a5ffa6-008d-4479-a625-53a00cef728b", "node_type": "1", "metadata": {"Header_1": " Load nodes into Timescale Vector vector store", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "e807f457dcd19000ad81e13fc624fc0cb7755157515f144488e540fad8084f2b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "35b2cc6d-d948-4cee-8863-efe60ad42a2a", "node_type": "1", "metadata": {"Header_1": " Powering Retrieval Augmented Generation With Time-Based Context Retrieval"}, "hash": "5e63eec87ed53a3e630355c35a7e42badf43ee7f4a65ad8c4139daf9ab4a083b", "class_name": "RelatedNodeInfo"}}, "text": "Similarity search with time filters\n\nNow that we\u2019ve loaded our nodes that contain vector embeddings data and\nmetadata into a Timescale Vector vector store, and enabled automatic time-\nbased partitioning on the table our vectors and metadata are stored in, we can\nquery our vector store with time-based filters as follows:\n\n    \n    \n    # Query the vector database\n    vector_store_query = VectorStoreQuery(query_embedding = query_embedding, similarity_top_k=5)\n    \n    # Time filter variables for query\n    start_dt = datetime(2023, 8, 1, 22, 10, 35) # Start date = 1 August 2023, 22:10:35\n    end_dt = datetime(2023, 8, 30, 22, 10, 35) # End date = 30 August 2023, 22:10:35\n    \n    # return most similar vectors to query between start date and end date date range\n    # returns a VectorStoreQueryResult object\n    query_result = ts_vector_store.query(vector_store_query, start_date = start_dt, end_date = end_dt)\n\nLet\u2019s take a look at the date and contents of the nodes returned by our query:\n\n    \n    \n    # for each node in the query result, print the node metadata date\n    for node in query_result.nodes:\n       print(\"-\" * 80)\n       print(node.metadata[\"date\"])\n       print(node.get_content(metadata_mode=\"all\"))\n    \n    \n    --------------------------------------------------------------------------------\n    2023-08-3 14:30:23+0500\n    commit:  7aeed663b9c0f337b530fd6cad47704a51a9b2ec\n    author: Dmitry Simonenko\n    date: 2023-08-3 14:30:23+0500\n    \n    Thu Aug 3 14:30:23 2023 +0300 Dmitry Simonenko Feature flags for TimescaleDB features This PR adds..\n    --------------------------------------------------------------------------------\n    2023-08-29 18:13:24+0320\n    commit:  e4facda540286b0affba47ccc63959fefe2a7b26\n    author: Sven Klemm\n    date: 2023-08-29 18:13:24+0320\n    \n    Tue Aug 29 18:13:24 2023 +0200 Sven Klemm Add compatibility layer for _timescaledb_internal functions With timescaledb 2.12 all the functions present in _timescaledb_internal were\u2026\n    --------------------------------------------------------------------------------\n    2023-08-22 12:01:19+0320\n    commit:  cf04496e4b4237440274eb25e4e02472fc4e06fc\n    author: Sven Klemm\n    date: 2023-08-22 12:01:19+0320\n    \n    Tue Aug 22 12:01:19 2023 +0200 Sven Klemm Move utility functions to _timescaledb_functions schema To increase schema security we do not want to mix\u2026\n    --------------------------------------------------------------------------------\n    2023-08-29 10:49:47+0320\n    commit:  a9751ccd5eb030026d7b975d22753f5964972389\n    author: Sven Klemm\n    date: 2023-08-29 10:49:47+0320\n    \n    Tue Aug 29 10:49:47 2023 +0200 Sven Klemm Move partitioning functions to _timescaledb_functions schema To increase schema security\u2026\n    --------------------------------------------------------------------------------\n    2023-08-9 15:26:03+0500\n    commit:  44eab9cf9bef34274c88efd37a750eaa74cd8044\n    author: Konstantina Skovola\n    date: 2023-08-9 15:26:03+0500\n    \n    Wed Aug 9 15:26:03 2023 +0300 Konstantina Skovola Release 2.11.2 This release contains bug fixes since the 2.11.1 release\u2026\n\nSuccess! Notice how only vectors with timestamps within the specified start\nand end date ranges of 1 August, 2023, and 30 August, 2023, are included in\nthe results.\n\nHere\u2019s some intuition for why Timescale Vector\u2019s time-based partitioning\nspeeds up ANN queries with time-based filters.\n\nTimescale Vector partitions the data by time and creates ANN indexes on each\npartition individually. Then, during search, we perform a three-step process:\n\n  * Step 1: filter our partitions that don\u2019t match the time predicate. \n  * Step 2: perform the similarity search on all matching partitions. \n  * Step 3: combine all the results from each partition in step 2, rerank, and filter out results by time. \n\nTimescale Vector leverages [ TimescaleDB\u2019s hypertables\n](https://docs.timescale.com/use-timescale/latest/hypertables/about-\nhypertables/) , which automatically partition vectors and associated metadata\nby a timestamp. This enables efficient querying on vectors by both similarity\nto a query vector and time, as partitions not in the time window of the query\nare ignored, making the search a lot more efficient by filtering out whole\nswaths of data in one go.\n\nWhen performing a vector similarity search on `TimescaleVectorStore`, rather\nthan specifying the start and end dates for our search, we can also specify a\ntime filter with a provided start date and time delta later:\n\n    \n    \n    # return most similar vectors to query from start date and a time delta later\n    query_result = ts_vector_store.query(vector_store_query, start_date = start_dt, time_delta = td)\n\nAnd we can specify a time filter within a provided end_date and time delta\nearlier. This syntax is very useful for filtering your search results to\ncontain vectors before a certain date cutoff.\n\n    \n    \n    # return most similar vectors to query from end date and a time delta earlier\n    query_result = ts_vector_store.query(vector_store_query, end_date = end_dt, time_delta = td)", "mimetype": "text/plain", "start_char_idx": 17275, "end_char_idx": 22332, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35b2cc6d-d948-4cee-8863-efe60ad42a2a": {"__data__": {"id_": "35b2cc6d-d948-4cee-8863-efe60ad42a2a", "embedding": null, "metadata": {"Header_1": " Powering Retrieval Augmented Generation With Time-Based Context Retrieval", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4dcbce51-7d99-4fa5-a0b2-a2ca29d74404", "node_type": "1", "metadata": {"Header_1": " Similarity search with time filters", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "46c14222fa16eb39a8479cdecc12dc94d6865572c1f531b524d41e5da4fd7080", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6a67bb1a-d2d3-4dcb-b853-5122bdc4ef65", "node_type": "1", "metadata": {"Header_1": " Resources and next steps"}, "hash": "f7214c8e30b752f5f512f1a5fd6390f04e25171ba07f7591aa190ff2d5b0288a", "class_name": "RelatedNodeInfo"}}, "text": "Powering Retrieval Augmented Generation With Time-Based Context Retrieval\nin LlamaIndex Applications With Timescale Vector\n\nLet\u2019s put everything together and look at how to use the TimescaleVectorStore\nto power RAG on the git log dataset we examined above.\n\nTo do this, we can use the TimescaleVectorStore as a [ QueryEngine\n](https://gpt-\nindex.readthedocs.io/en/latest/api_reference/query/query_engines.html) . When\ncreating the query engine, we use TimescaleVector\u2019s time filters to constrain\nthe search to a relevant time range by passing our time filter parameters as\n`vector_strore_kwargs`.\n\n    \n    \n    from llama_index import VectorStoreIndex\n    from llama_index.storage import StorageContext\n    \n    index = VectorStoreIndex.from_vector_store(ts_vector_store)\n    query_engine = index.as_query_engine(vector_store_kwargs = ({\"start_date\": start_dt, \"end_date\":end_dt}))\n    \n    query_str = \"What's new with TimescaleDB functions? When were these changes made and by whom?\"\n    response = query_engine.query(query_str)\n    print(str(response))\n\nWe asked the LLM a question about our gitlog, namely, \u201cWhat\u2019s new with\nTimescaleDB functions. When were these changes made and by whom?\u201d\n\nHere\u2019s the response we get, which synthesizes the nodes returned from semantic\nsearch with time-based filtering on the Timescale VectorStore:\n\n    \n    \n    TimescaleDB functions have undergone changes recently. These changes include the addition of several GUCs (Global User Configuration) that allow for enabling or disabling major TimescaleDB features. Additionally, a compatibility layer has been added for the \"_timescaledb_internal\" functions, which were moved into the \"_timescaledb_functions\" schema to enhance schema security. These changes were made by Dmitry Simonenko and Sven Klemm. The specific dates of these changes are August 3, 2023, and August 29, 2023, respectively.\n\nThis is a simple example of a powerful concept \u2014 using time-based context\nretrieval in your RAG applications can help provide more relevant answers to\nyour users. This time-based context retrieval can be helpful to any dataset\nwith a natural language and time component. Timescale Vector uniquely enables\nthis thanks to its efficient time-based similarity search capabilities, and\ntaking advantage of it in your LlamaIndex application is easy thanks to the\nTimescale Vector integration.", "mimetype": "text/plain", "start_char_idx": 22337, "end_char_idx": 24707, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6a67bb1a-d2d3-4dcb-b853-5122bdc4ef65": {"__data__": {"id_": "6a67bb1a-d2d3-4dcb-b853-5122bdc4ef65", "embedding": null, "metadata": {"Header_1": " Resources and next steps", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8", "node_type": "4", "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "3cbeb17257d6b045cdd71bcd517d510e3d408d64c6949e7163fc6a7e4aad699d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "35b2cc6d-d948-4cee-8863-efe60ad42a2a", "node_type": "1", "metadata": {"Header_1": " Powering Retrieval Augmented Generation With Time-Based Context Retrieval", "filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}, "hash": "ca31667b5cdaf2b166a712b36fc08e2a6ae8b9af83074d16d878b89cd901ba8a", "class_name": "RelatedNodeInfo"}}, "text": "Resources and next steps\n\nNow that you\u2019ve learned how Timescale Vector can help you power better AI\napplications with PostgreSQL, it\u2019s your turn to dive in. Take the next step in\nyour learning journey by following one of the tutorials or reading one of the\nblog posts in the resource set below:\n\n  * [ **Up and Running Tutorial** ](https://gpt-index.readthedocs.io/en/stable/examples/vector_stores/Timescalevector.html) **:** learn how to use Timescale Vector in LlamaIndex using a real-world dataset. You\u2019ll learn how to use Timescale Vector as a Vectorstore, Retriever, and QueryEngine and perform time-based similarity search on vectors. \n  * [ **Timescale Vector explainer** ](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-database/?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral) : learn more about the internals of Timescale Vector. \n  * [ **Timescale Vector website** ](https://www.timescale.com/ai) **:** learn more about Timescale Vector and Timescale\u2019s AI Launch Week. \n\n**And a reminder:** [ **LlamaIndex Users get Timescale Vector free for 90\ndays**\n](https://console.cloud.timescale.com/signup?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral)\n\nWe\u2019re giving LlamaIndex users an extended 90-day trial of Timescale Vector.\nThis makes it easy to test and develop your applications on Timescale Vector,\nas you won\u2019t be charged for any cloud PostgreSQL databases you spin up during\nyour trial period. [ Try Timescale Vector for free today\n](https://console.cloud.timescale.com/signup?utm_campaign=vectorlaunch&utm_source=llamaindex&utm_medium=referral)\n.", "mimetype": "text/plain", "start_char_idx": 24712, "end_char_idx": 26338, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/metadata": {"c841782b-c9ba-4fda-b0b8-8bd2cb03396b": {"doc_hash": "32a9aa0df5d87b2e6abcbe3f00f732db49b68042eeaaf323878714476a0807af", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "8d63857f-44bf-45f5-a327-5833745751d6": {"doc_hash": "7ee6f257cf171c89e664bdf78a31f5627dd3ee3421b430e39d6b98c51017b7a8", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "d44c680f-4c50-4825-9022-36ee14d6997d": {"doc_hash": "528c837f4930444b78a773e53427158dfbf7dea1b401133e9cb39ac97b7e3d25", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "d12bd5ff-cac6-47d9-8016-9aa45a77c68b": {"doc_hash": "751691c06a58702887c72151b40b79abd2fd5f32c865caa277fd3a67603e6a38", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "9802ab2e-05ae-463e-8d10-8239ad0af361": {"doc_hash": "9abb3926b0b99088756df32ab5c663aa67e45b57449b0b2b05c3cba9a96e0e4f", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "9e4aaf3b-a14d-4b8f-b007-189ecba2c058": {"doc_hash": "ce4a038d40d37d51340033bbebf01cf687acbc4eea7c6ff5a55f1718bc50482a", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "01a5ffa6-008d-4479-a625-53a00cef728b": {"doc_hash": "e807f457dcd19000ad81e13fc624fc0cb7755157515f144488e540fad8084f2b", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "4dcbce51-7d99-4fa5-a0b2-a2ca29d74404": {"doc_hash": "46c14222fa16eb39a8479cdecc12dc94d6865572c1f531b524d41e5da4fd7080", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "35b2cc6d-d948-4cee-8863-efe60ad42a2a": {"doc_hash": "ca31667b5cdaf2b166a712b36fc08e2a6ae8b9af83074d16d878b89cd901ba8a", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}, "6a67bb1a-d2d3-4dcb-b853-5122bdc4ef65": {"doc_hash": "a53cca9c6f45d64bf788327e2128945674ea21daad30799554672132192efde9", "ref_doc_id": "9f4b7b59-5833-42e8-bddf-699efedce5f8"}}, "docstore/ref_doc_info": {"9f4b7b59-5833-42e8-bddf-699efedce5f8": {"node_ids": ["c841782b-c9ba-4fda-b0b8-8bd2cb03396b", "8d63857f-44bf-45f5-a327-5833745751d6", "d44c680f-4c50-4825-9022-36ee14d6997d", "d12bd5ff-cac6-47d9-8016-9aa45a77c68b", "9802ab2e-05ae-463e-8d10-8239ad0af361", "9e4aaf3b-a14d-4b8f-b007-189ecba2c058", "01a5ffa6-008d-4479-a625-53a00cef728b", "4dcbce51-7d99-4fa5-a0b2-a2ca29d74404", "35b2cc6d-d948-4cee-8863-efe60ad42a2a", "6a67bb1a-d2d3-4dcb-b853-5122bdc4ef65"], "metadata": {"filename": "timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0.md", "extension": ".md", "title": "Timescale Vector x LlamaIndex: Making PostgreSQL a Better Vector Database for AI Applications", "date": "Sep 27, 2023", "url": "https://www.llamaindex.ai/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications-924b0bd29f0"}}}}